# data structure and algorithm



# First Review Questions


## Depth 와 Degree 의 차이는?

어느 분야든 마찬가지이겠지만, tree라고 하는 자료구조는 선택된 노드에 따라 역할과 관계가 바뀌기 때문에 용어를 정확히 이해하는 것이 중요하다. Depth는 선택된 노드로 부터 트리의 루트 노드까지의 edge의 수이다. 이 때 루트 노드의 depth 는 0이다. Depth와 대비되서 이해해야 하는 용어는 height이다. height는 루트 노드에서 가장 먼 leaf 노드까지의 edge의 수이다.  

Degree는 노드에서의 정의와 트리에서의 정의로 나눠 생각할 수있다. 노드의 degree는 해당 노드의 child의 수로 정의 된다.  트리에 포함된 모든 노드들 중 degree가 가장 큰 노드의 값이 트리의 degree이다.  



## 책에서는 full tree 에서 모든 가지가 자신이 가질 수 있는 모든 자식을 가지고 있는 것이라 했는데, ppt에서는 full binary tree가 모든 가지가 2개 또는 0개의 자식을 가지고 있는 것이라고 나타나 있다. 다른 것인가요?

Tree와 binary tree는 서로 다르지만 트리에서 사용했던 용어들을 binary tree에서도 똑같이 적용할 수 있다. Binary  tree의 경우 자식이 없더라도 binary tree라고 부른다. full binary tree도 같은 식으로 이해할 수 있다. 각 binary tree의 노드가 자식이 2개가 있거나 하나도 없다면 그것은 full binary tree이다. k-ary tree로 개념을 확장하더라도 동일하다. 각 노드가 k개의 자식이 있거나 하나도 없다면 full k-ary tree이다. 노드에 자식이 없는 경우, 다시 말하면 leaf 노드는 자식이 없는 노드를 뜻하는데, Full tree 에서 0개의 자식을 갖고 있는 경우를 명시하지 않는다면 트리의 height가 무한이 될 것이다. 





## complete tree가 가지는 의미는 ? 굳이 명명하는 이유와 반드시 왼쪽부터 채워져야 하는 이유는? (유사질문) complete tree 에서 맨 마지막 leaf 사이에 하나만 비면 이 경우 성립하는 이유가 무엇인가요? (유사 질문) Complete binary tree를 정의할 때 deepest level의 빈 노드의 위치를 구분 짓는 이유는 (왼쪽 or 오른쪽) (유사질문) 이진 트리에서 complete tree와 full tree를 구별하는 방법 (유사질문) complete tree 와 full tree 구별 방법과 차이점



Full tree는 모든 노드가 최대 자식의 수만큼 갖고 있거나 하나도 없는 경우라고 정의를 하였다. complete tree도 동일한 정의를 갖고 있으나 거기에 한가지 조건이 더 추가 되었다. 마지막 노드의 경우에는 child를 왼쪽에서부터 채워져야 한다는 조건이다. Complete tree의 정의의 문제이다. 모든 노드들이 순서대로 좌측에서 우측까지 정렬이 되어 있다. N번 째 노드 이후에 N+2번째의 노드가 있다면 complete tree의 조건에 위배된다. 





## sub tree 는 child가 존재할 때 사용하는 용어인가요?

Child가 있는 경우만 subtree가 존재할 수 있다.  



## sibling에서 child가 자신이면 이것을 sibling으로 치나요? (유사질문) sibling이 하나만 존재할 때도 성립하는가?



Sibling 은 같은 부모를 둔 자식들이 하나 초과일 때 사용할 수 있는 용어다. 





## 하나의 노드는 데이터를 하나만 가질 수 있다는 말은 틀렸는데, 그렇다면 데이터를 하나도 가지고 있지 않거나, 여러개를 가진다면 갯수가 유한한지

노드는 정의하기에 따라 데이터를 하나만 또는 하나도 갖고 있지 않을 수도 있고 메모리가 허용하는 한 많은 멤버 변수들을 갖을 수가 있다. 그 선택은 사용자의 프로그램의 목적에 따라 정의되어야 한다. 



## 레벨은 루트에서 시작할 때 루트를 1로 둘지 2로 둘지 선택하는데, 어떤 것을 선택해도 상관없는지

루트 노드의 레벨은 0 또는 1로 정의한다. 기준이 사용하는 사람마다 다를 수 있기 때문에 혼돈을 피하기 위해 루트노드의 레벨을 명시하고 나서 트리의 전체 레벨을 표현하는 것이 좋다. 



## 이진 트리에서 왼쪽 skewed 트리와 오른쪽 skewed 트리에서 사용된 차수, 레벨 깊이 루트 등이 같은데 오른쪽 공백과 왼쪽 공백을 가진 것만으로 다르다고 하는 것인지

skewed tree는 왼쪽 또는 오른쪽으로만 자식이 추가되는 경우의 트리의 상태를 표현하는 용어이다. 왼쪽으로만 추가되는 경우는 left skewed tree그리고 오른쪽으로만 추가되는 경우를 right skewed tree이다. 



## 편향 트리와 완전 이진 트리는 어떤 용도로 다르게 사용되는지 궁금합니다.

트리의 장점 중 하나는 모든 노드들의 루트로부터의 접근 거리가 일정하다는 것이다. Skewed 트리의 경우 한쪽으로 쏠려있기 때문에 루트에서 마지막 노드에 대한 접근 거리가 linked list와 같게 되어 이득이 전혀 없어진다. 그러한 경우 트리의 노드들을 재배치하는 작업이 필요하다. binary tree의 경우 노드의 값들이 크기를 비교하여 왼쪽 또는 오른쪽에 배치하기 때문에 left skewed 또는 right skewed 에 따라 재배치 알고리즘이 변형되어야 한다. 

Complete binary tree의 경우 모든 노드들이 순서대로 연속적으로 배치되어 있다는 성질을 갖고 있다. 그 성질을 이용하여 루트 노드에 항상 최대 값 또는 최소 값을 배치하는 Max heap과 Mean heap으로 활용할 수가 있다. 





## NODE는 데이터 주소(포인터)를 가지는데 주소가 어떻게 edge가 어떻게 되는지

포인터는 프로그래밍 수준에서 하나의 노드와 다른 노드를 연결한다. 논리적으로 하나의 노드와 다른 노드의 연결을 edge라고 부른다.



## 부모가 가르키는 자식을 부모가 자식을 포인팅하는 거라고 하였는데 자식도 부모를 가르키지 않는지

자료 구조의 정의에 따라 부모만 자식을 포인팅하는 구조를 갖을 수도 있고 자식도 부모를 포인팅하도록 만들 수 있다. 하지만 그렇게 만들기 위해서는 먼저 목적과 비용에 대해 생각해보고 결정해야 한다.





## linked list representation 에서 sibling은 표기 하지않을 때 sibling을 어떻게 구분할 수 있을가?

* sibling은 표기하지 않는다 (따로 표기하는 약식이 없으므로) 따라서 그냥 같은 parent를 가진 노드이면 그냥 sibling으로 보면 된다





## Binary tree 는 왜 tree의 부분 집합이 아닌지? (유사질문) binary tree와 tree의 차이점에서 leaf node 수 (N0) 와 차수 2(N2)의 node 수 사이의 관계  N0= N2+1이 무엇을 의미하는지

Tree는 노드들의 순서에 상관이 없는 반면에 binary tree는 노드들 간의 순서와 크기의 차이가 있으며 노드의 값에 따라 재배치가 일어날 수 있다. 그러므로 tree와 binary tree는 서로 전혀 다르다.  

질문의 상관 관계를 표현한 식의 설명은 다음과 같다. Relationship between the number of leaf nodes (n0) and  the number of nodes with degree 2 (n2) 라는 의미는 degree가 2인 어떤 노드와 leaf node들과의 관계를 말하고 있다. 즉 하나의 노드는 두개의 자식 또는 leaf node를 갖을 수 있으므로 총 노드의 수는 3개가 된다. Degree 의 수와 해당 노드들의 부모를 합한 값이다. 





## A는 parent이자 node 이다. 그렇다면 B 또한 parent 가 될 수 있는가?

— B는 child 이자 parent 이다. c는 child에만 해당한다



## 이진 트리의 개수를 알아볼 때 2^k-1과 2^{K+1}-1의 차이는?

Binary tree가 가질 수 있는 최대 노드의 갯수를 계산할 때 2^k-1을 사용한다. 이 때 k는 tree의 depth 이다. Depth를 deepest level의 노드로부터 루트까지의 edge의 수로 정의 하면 k+1, 노드의 수로 정의하면 k로 계산 할 수 있다. 정의의 기준에 따라 k또는 k+1로 표현될 수 있다.









## 리스트에서 current.val 이 아닌 current->val을 사용하는 이유는?

dot (.) operator는 structure의 member 변수를 접근 할 때 사용되는 operator이다. 예를 들어 다음과 같이 count라는 structure가 정의 되었다고 해보자.  

typedef struct count {

       int value

} count

이 때 count current라고 는 변수를 새로 정의하면 current 라는 변수의 member value를 접근하기 위해서는 current.value 라고 해야 그 값을 읽거나 변경할 수 있다. 

temp->val 에서는 ->라는 표기로 member 변수를 접근하고 있다. 차이가 있다면  포인터 변수인 temp가 current를 가리키고 있다는 것이다. 그 것을 표현하기 위해 ->가 사용된다. 





## 리스트에 테일이 존재하는 이유

리스트에는 헤드와 테일이 존재한다. Singly linked list의 경우 리스트의 임의의 노드에서 자신을 참조한 노드를 찾아 갈 방법이 없기 때문에 리스트의 시작 노드를 알지 못한다면 모든 노드들을 순회할 수 있는 방법이 없다.  그리고 \0으로 포인터가 더 이상 어떤 곳을 가리키지 못하도록 막아 둔 테일 노드를 정의해 놓지 않으면 마지막 노드의 포인터를 통해 임의의 주소공간을 접근하게 된다. 정의되어 있지 않은 공간이나 운영체제의 공간을 침범하게 되면 프로그램은 오동작을 하게 되고 치명적인 오류를 일으킬 수도 있다. 

 

## 트리 구조는 어떤 때 사용해야 하는지 (유사질문) 컴퓨터 프로그래밍으로써 이러한 트리가 어떤 부분에 주로 사용되는지 궁금합니다. (유사질문) 트리 구조를 사용할 때의 장단점은 무엇인지

트리의 장점은 배치가 잘되어 있다면 노드의 수가 많아지더라도 도달하는 데 드는 비용이 일정하다는 것이다. Skewed tree의 경우 재배치하는데 드는 비용이 있겠지만, 한번 균형이 잡히도록 재배치 해놓고 삽입할 때 균형을 잃지 않도록 유지 한다면 항상 접근 비용이 일정하게 유지할 수 있다. 이와 같은 성질을 이용하여 자료의 삽입과 탑색이 빈번한 데이터베이스에 사용될 수도 있다. 자료의 유지 관리하는 용도로 주로 쓰인다. 





## ancestor와 descendant 는 조상과 자손의 의미인데 교수님께서 git에 올려주신  pdf에는 조상과 자손에 본인도 포함된다고 되어 있습니다. 책엔 본인은 포함되지 않는다고 하는데, 어떤 것이 맞는 것인지 궁금합니다.

발표자료에 오해가 있게 작성이 되어 있어 수정이 필요하다. x의 descendant는 x와 그의 자식들의 관계를 표현한다. 설명에서 포함되는 것이지 실제 descendant 는 그 자식들이다. Ancestor도 마찬가지로 자식과 해당 자식의 parent와 grandparent등을 말하는 것이다. 




# Second Review Questions

## 재귀용법을  사용하지 않고 직관적인 코드를 짜야하는 경우? (유사질문) 재귀용법을 사용할 수 없는 경우는?
재귀용법을 사용하지 말아야 하는 경우는 없습니다. 프로그래머가 코딩할 때 어떤 것이 더 편한지에 따라 정하면 됩니다. 그러나 재귀적 호출을 하는 횟수가 너무 많아지면 스택의 범위를 초과하는 경우가 발생할 수 있고, 종료조건을 제대로 정의하지 않은 경우에도 마찬가지로 스택 오버플로우가 생길 수 있습니다. 이 사실을 기억하고 코딩해야 합니다. 


## Max heap의 시간복잡도가 binary tree의 개수인 O(log2n)이 되는 이유는? O(log2(n+1)) 은 아닌지?
로그 식을 전개하면 O(log2n)이 됨

## 이진트리 순회할 때 왼쪽 방향 순회 후 오른쪽 방향 순회 순으로 순회하는데 오른쪽 방향 먼저 하는 것이 가능한가? 왼쪽 방향으로 설정한 이유가 따로 있는가?
용도와 사용은 필요에 따라 정의 될 수 있기 때문에 오른쪽 방향 먼저 탐색하는 것도 가능합니다. 순회한다는 것은 어떤 정의된 규칙을 따라 삽입되어 있는 값들을 읽어오는 것이기 때문에 오른쪽으로부터 순회하려면 의도한 결과대로 출력하기 위해서는 삽입연산의 동작도 바뀌어야 합니다. 

## (레벨 순서 순회할 때 순서 할당 기법에 따라 노드들이 출력되는 방법은 알겠으나 루트를 큐에 삽입하는 방법을 모름) 레벨 순서 순회할 때 루트를 큐에 삽입하는 방법은? (유사질문) level order traversal의 순서가 정확하게 어떻게 되는지

레벨 순회의 기본 동작은 현재 노드의 자식들을 큐에 enqueue하고 dequeue는 것입니다. 그러기 위해서는 먼저 큐에 노드를 enqueue 하고 dequeue하는 함수를 만들어야 합니다. 큐를 다뤘던 장을 복습해야겠지요. 큐의 동작에 대해서 간단하게 설명하면 FIFO입니다. 먼저 들어온 순서대로 큐에서 빠져나간다는 뜻입니다. 편의점에서 물건을 사려고 결제라인에 줄을 서서 계산 후에 매장을 나가는 것을 연상해보면 좋겠습니다. 결제 라인에 언제 줄을 서는 동작이 enqueue 이고 결제를 하는 동작이 dequeue 동작입니다. 레벨 순회의 동작으로 돌아가서 큐가 어떻게 활용되는지 이해해 봅시다. 레벨 순서에 가장 처음 노드는 루트입니다. 이 루트를 큐에 enqueue합니다. 그리고 큐에서 dequeue 하면서 자식 노드들을 확인합니다. 왼쪽과 오른쪽 자식을 enqueue합니다. 큐에 있는 처음 노드를 dequeue 하고 그 자식들이 있으면  그 자식들도 enqueue 합니다. 그 이후에는 큐의 다음 노드를 dequeue하고 그 자식들을 enqueue하는 동작을 반복합니다.



## 책에 나온 for(;;)문은 처음 보는 형태 입니다.  이것도 while(1)과 같은 무한 반복문 인가요? 
코드는 자기 손으로 작성하고 실행해봐야 합니다. 어떤 것들은 논리적으로 생각해서 해답을 얻을 수 있지만, 처음 시작은 모두 실행해보고 왜 그런지 생각해봐야 합니다. for(;;) 으로 예제 코드를 만들어서 실행 해보면 while(1)과 같은지 바로 알 수 있습니다. 
```
void main(){
    for(;;)
        ;
}
```
for 문에는 종료 조건을 명시해야 하는데 그 조건이 없기 때문에 위 코드는 무한반복을 합니다. for (i=0; ; i++) 의 경우는 어떻게 될지 생각해보기 바랍니다.

## 힙 단원에서 우선순위 큐 부분에서 theta notation은 처음봐서 모르겠습니다. 
Big Oh notation을 할 때 Omega notation과 theta notation 에 대해서 설명을 했었습니다. Big Oh notation  은 worst case, Omega notation 은 best case 그리고 theta notation 은 평균이라고 설명했습니다. 

## 일반 수식을 postfix로 고치기 위해 이진트리 순회에 넣는 방법은? (유사 질문) infix인 수식을 postfix 나 prefix로 고치기 위해 이진 트리에 넣는다고 했을 때 어떤 방법으로 트리 구조에 넣어야 하는지?
일반 수식을 이진 트리에 넣는 방법은 수업에서 다루지 않았습니다. 이 부분은 preorder 방식으로 삽입하면 어떨까요? 생각해보시기 바랍니다.

## binary tree로 연산식 (ex. 10+20 * (30-90)) 등을 어떻게 순서대로 집어 넣을 수 있을까요? 만약 연산한다면 어떤 방식을 탐색해야 합니까?
산술식을 먼저 binary tree에 넣을 수 있게 재배치를 해야겠지요.  위의 질문과 같이 preorder로 식을 재정리하고 그에 맞게 트리에 삽입해볼 수 있겠습니다.

## 힙이 우선 순위에 따라 작업을 실행하는 방법 (유사질문) 힙이 우선 순위를 정해 작업을 실행할 수 있는 이유 (유사질문) heap과 우선 순위 큐의 연관성 (유사질문) 힙이 정확이 무엇인지 힙를 사용하는 이유도 궁금합니다.

힙은 max 또는 min 힙 두 가지가 있습니다. 성질을 보면 힙에 포함되어 있는 값들 중 항상 최대 큰 값 또는 작은  값을 즉시 쓸 수 있도록 만들어졌습니다. 어떤 작업을 우선순위에 맞게 처리해야 한다고 하면 힙의 성질이 매우 유용하게 활용될 수 있습니다. 작업이 힙에 어떤 순서대로 삽입이 되던 루트 노드는 항상 최대 또는 최소의 값을 갖고 있는 노드이기 때문입니다. 연결 리스트나 베열과 같은 구조를 생각해봅시다. 우선 순위에 맞게 어떤 노드를 꺼내려면 모든 값을 매번 순회해서 최대 또는 최소 값을 찾아야 합니다. 정렬이 되어 있는 연결 리스트나 배열이었다면 가장 앞의 값이 원하는 값이겠지요. 그러나 정렬에 대한 비용이 있습니다. 

## 이진 트리의 높이 구하는 방법?
트리의 높이를 구하려면 몇개의 노드가 트리에 있는지 알아야 합니다. leaf 노드를 찾고 루트까지 도달하는데 몇 개의 edge를 지나가면 되는지 세야 합니다.

## 트리와 연결 리스트의 차이점?
연결 리스트에는 계층적 개념이 없습니다. 단 하나의 노드에 대한 정보를 알고 있습니다.  반면 트리는 계층적입니다. 자식과 부모의 관계에 따라 상관관계가 있는 정보를 다루고 있습니다. 


## 최대 힙이 사용될 때 push pop의 복잡도가 왜 O(logn)인지 (유사질문) 힙는  insertion과 deletion의 속도가 같다고 하셨는데 왜 그런가요? (유사질문) max heap 의 insertion, deletion의 big-oh가 왜 O(logn)인지 궁금합니다.
Max heap에서 루트 노드를 꺼내는 동작을 pop이라고 하고  heap삽입하는 동작을 push라고 합시다. pop 의 경우 로투 노드를 꺼내고 나면 heap에 속해 있는 값들 중에 가장 큰 값을 루트에 재배치를 해야 합니다. 이 동작에는 heap에 있는 노드들을 탐색하고 위치를 이동하는 비용이 포함됩니다. 어떤 레벨에 가장 큰 값이 있는지 찾아야하겠지요. Big oh 표기는 최악의 경우의 값을 정의하는 것입니다. 노드의 개수를  n이라고 하면 레벨을 한 번씩 내려갈 때마다 지수적으로 찾아야 하는 노드의 수가 줄어듭니다. 지수적으로 감소하는 경우를 logn으로 표기할 수 있기 때문에 O(logn) 입니다. Push 동작도 동일한 원리입니다. 대신 새로운 값을 삽입할 때라는 점이 다릅니다.

## 우선 순위 큐에서 is_empty함수가 O(1)시간이 걸리고 top()함수가 theta(n) 시간이 걸리는 이유와 최대 힙이 사용될 때 is_empty와 top의 복잡도가 O(1)이고 push 와 pop 이 O(logn)인 이유를 모르겠습니다.
push/pop의 복잡도는 위의 질문 참고

is_empty()는 큐가 비어 있지 않았는지 확인하는 작업입니다. 몇개의 명령어들로 이루어져 있지만 상수 시간에 끝나기 때문에 O(1)입니다.  

## Heap과 Heaps의 차이점?
정확하게는 운영체제의 heap과 자료구조의 heap을 비교해야 합니다. 운영체제가 관리하는 heap은 실행 중인 프로그램(프로세스)이 사용하는 주소 공간에 동작으로 할당되는 변수들을 저장하기 위한 공간입니다. 자료구조의 heap은 최대 또는 최소 값이 루트에 있
도록 하는 방법입니다.

## 산술식을 이진 트리로 표현하면 순회 방법에 따라 값이 달라질 수도 있는지
이진트리에 삽입되어 있는 산술식은 순회 방법에 따라 표기방법이 바뀌지만 연산의 값은 바뀌지 않습니다.

## 우선 순위 큐와 큐의 차이가 무엇인지, 우선 순위가 가장 높거나 낮음이 큐의 선입 선출과는 어떻게 다른지
일반적인 큐는 들어온 순서대로 나가는 FIFO 입니다. 우선 순위 큐는 Max heap 또는 Min heap을 활용하여 큐에 정렬된 값이 FIFO  형태로 출력됩니다.

## tree를 binary  tree로 바꿨을 때 binary tree 라는 표시를 해주지 않으면 그냥 tree인지, binary tree 인지 잘 구별할 수 없을 것 같은데 어떻게 구분해주나요
한 자료구조에서 다른 자료구조로 변환할 때는 그 성질에 맞게 데이터를 배치해주어야 하기 때문에 예외 케이스들을 다뤄줘야 합니다. 개발자가 두 자료구조에 대해 알고 변환 과정을 처리 해야 한다는 뜻입니다. 

## preorder, postorder이 prefix와 postfix라 같은 건가요
수식에 연산자의 위치에 따라 prefix와 Infix, postfix라고 표현합니다. 트리를 순회하는 방법에 따라 preorder, inorder, postorder라고 표현합니다. 유사하지만 다른 방법입니다. 
## 이진 트리에서 삽입할 값이 이미 있는 키값이라면 어떻게 해야 하나요?
중복된 값을 표현할 수 있도록 만들것인지를 먼저 정해야 합니다. 중복을 허용하는 경우에 중복된 값을 어떻게 표현할지를 그 다음에 생각해야 합니다. 중복 카운터를 해당 노드에 표현할 수도 있고 새로운 노드를 추가 할 수도 있습니다. 필요와 용도에 따라 구현해야 합니다. 

## 이진 트리순회를 표현하는 프로그램의 코드 중에서 `ptr->right_child` 와 `node->right_child`의 차이점을 모르겠습니다.
ptr도 node도 tree_ptr이라는 자료구조 형으로 선언된 변수입니다. 프로그램의 코드에서 역할을 파악해야합니다. 


## 이원 탐색 트리로 사칙연산을 표현할 수 있나요?
탐색트리의 목적은 자료의 검색입니다. 사칙 연산을 표현할 수는 있으나 operator를 비교하는 기준이 필요하겠습니다. 숫자의 글자를 비교한다는 것을 정의하기 전까지는 사칙연산을 표현할 수 없습니다. 

 
## 이진트리 순회에서 iterative inorder 를 쓸 수 밖에 없는 경우가 있다고 했는데 그게 뭔지 모르겠어요
recursive의 코드가 명료하기 때문에 할 수 있다면 recursive로 코드를 짜면 좋습니다. 그렇다고 iterative 방법보다 좋다는 뜻은 아닙니다. 개발자가 읽기 편하고 쓰기 편한 코드가 더 좋은 코드입니다. 
질문에서 iterative inorder를 쓸 수 밖에 없는 경우를 물었는데, 그 경우는 recursive하게 함수 호출하는 횟수가 엄청나게 많은 경우 입니다. 종료 조건없이 피보나치 수열을 출력하도록 만드는 경우를 생각해볼 수 있습니다. 운영체제가 다룰 수 없을 만큼 재귀적으로 호출을 하는 경우라면 iterative한 방법이나 더 효율적인 방법을 찾아야 합니다.

## post order 2 4 * 25 15 - + 가 왜 8 + 10 = 18이 되는 건가요? 
위의 식을 원래의 infix식으로 표현하면 2 * 4 + 25 - 15이죠. 그 답은 18 입니다.  

 
## 연결 리스트로 된  heap과 배열로 된 heap의 둘의 의미와 차이
heap은 연결 리스트 또는 배열로 표현할 수 있습니다. 연결 리스트와 배열의 장단점을 비교해보면 둘 중에 어떤 자료구조를 언제 써야 할지 분명해집니다. 개수가 적은 경우 배열을 쓰면 좋습니다. 쉬운 연산으로 삽입되어야 하는 위치나 삭제해야 하는 값이 어디있는지 찾을 수 있기 때문입니다. 그러나 개수가 많아지면 데이터 이동해야하는 비용이 커지기 때문에 속도가 느려질 수 있습니다. 그 때에는 연결 리스트를 써야 합니다. 위치의 이동은 포인터의 이동으로 쉽게 해결 할 수 있기 때문입니다.

## 0  과 NULL 값의 차이
문자적으로 0은 int 형입니다. NULL은 포인터 값으로 엉뚱한 주소 공간을 포인트하지 않도록 하는데 사용됩니다. 일반적으로 모두 0으로 체워진 값으로 정의되어 있습니다.  
추가적으로 \0 은 null character로서 해당문자를 표현하기위해 사용되는 모든 비트의 값을 0으로 채운 값입니다. 

## 레벨 순서 순회는 왜 레벨이 작은 순으로 출력 되나요?
레벨 순서 순회는 루트에서부터 시작하여 레벨이 큰 순으로 증가하며 순회하는 방식입니다. 모든 노드들을 한 번 씩 탐색하는 순회 방식들 중 하나 입니다.

## Heap은 complete binary tree라고 명시되어 있는데 발표자료에 예시들이 complete binary 인지 궁금합니다.
Complete binary tree의 조건에 부합하지 않으면 아닙니다. 발표자료에 예시는 complete binary tree가 아닌 경우도 포함하고 있습니다. 

## heap은 binary tree에서만 존재하는가요? 일반적인 트리에서 heap 존재 가능성은 어떻게 되나요? 
위의 질문을 보면 heap은 complete binary tree이다고 질문을 하고 있습니다. 일반적인 트리에서는 heap 을 정의하면 탐색 시간이 더 길어지겠군요. 

## travel하면서 inorder 에서 한 번 확인을 한 후 null이면 그 위로 올라갈 텐데 포인터를 써야 하는 것 아닌가요? 강의자료에서는 바로 나와서 헷갈립니다. 그 위로 올라가는 명령어가 무엇인가요?
재귀적인 함수의 호출을 할 때 현재 실행 중인 정보들을 스택에 프레임이라는 이름으로 저장합니다. 그리고 새로운 프레임에 재귀적으로 호출된 함수의 정보들이 삽입됩니다. 자장 마지막으로 호출된 재귀 함수가 리턴하면 그 함수를 호출한 함수의 프레임의 정보를 스택에서 확인합니다. 그러면 그 때 사용했던 변수들의 정보를 그대로 활용할 수가 있습니다.  재귀함수에서 리턴하면  자신을 호출한 함수로 돌아갑니다. 

## 다음의 코드에서 `printf`는 한번인데 결과가 a/b가 나오는지 궁금합니다.
```
void inorder (tree_ptr ptr){
    if(ptr){
        inorder(ptr->left_child);
        printrf("%d", ptr->data);
        inorder(ptr->right_child);
}
```

재귀적으로 함수를 호출하고 있기 때문에 printf가 여러번 호출됩니다. inorder 함수가 호출되는 수만큼 나타납니다. 

